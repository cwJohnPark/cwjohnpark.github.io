---
title: "데이터 중심의 애플리케이션 설계 - 스트림 처리의 기본"
toc: true
categories:
  - tech
tags:
  - book
  - design system
  - tech
  - backend
---

배치 처리와 다르게 스트림 처리는 입력 데이터가 한정된다.
스트림 처리는 시간이 지남에 따라 점진적으로 도착하는 제한되지 않은 데이터를 처리하기 위한 솔루션이다.
스트림 처리를 사용하는 이유는 무엇일까? 스트림 처리를 사용하면 데이터 처리 지연을 줄일 수 있으며, 심지어 이벤트가 발생하는 즉시 처리할 수도 있다.

스트림 처리를 위해 알아야할 것들은 다음과 같다.

- 스트림 표현
- 저장
- 전송
- 스트림과 데이터베이스 간의 관계
- 연속 스트림 처리를 위한 도구

## 스트림 처리의 기본 단위, 이벤트

스트림 처리를 할 때 입력 파일은 타임스탬프와 함께 변경 불가능(immutable)한 작은 객체인 **이벤트**로 구분된다.

다음은 이벤트의 특징이다.

- 이벤트는 사용자 작업, 기계 측정 또는 로그에서 발생할 수 있다.
- 이벤트는 텍스트, JSON 또는 바이너리로 인코딩될 수 있다.
- 이벤트는 프로듀서가 생성하고 컨슈머가 처리하며, 종종 토픽이나 스트림으로 그룹화된다.

배치 프로세스는 *폴링(polling)*에 의존하여 새 데이터를 확인하는 반면, 스트림 프로세스는 지연이 적은 지속적인 처리를 위해 **이벤트 알림 메커니즘**을 사용한다. 기존 데이터베이스는 이를 지원하는 데 한계가 있어 이벤트 알림을 위한 도구가 개발된 것이다.

## 메시징 시스템

메시징 시스템은 프로듀서가 컨슈머에게 이벤트가 포함된 메시지를 보낸다.
메시징 시스템은 Unix 파이프나 TCP 연결과 같은 직접 통신 채널과 다르다.
메시징 시스템을 사용하면 여러 명의 프로듀서가 동일한 토픽에 대해 메시지를 보내고 여러 명의 컨슈머가 메시지를 받을 수 있다.

메시징 시스템의 가장 두드러진 특징은 두 가지다.

- 속도 처리: 프로듀서가 컨슈머가 처리할 수 있는 속도보다 빠르게 메시지를 보내는 경우, 메시지를 삭제하거나, 대기열에 버퍼링하거나, 역압박(프로듀서 차단)을 가하는 등의 옵션이 있다. 유닉스 파이프와 TCP는 백프레셔를 사용한다.

- 메시지 내구성: 노드 충돌 또는 다운타임이 발생하는 경우 메시지 내구성은 디스크에 쓰기 및/또는 복제에 따라 달라진다. 메시지 내구성을 선택하는 것은 애플리케이션의 요구 사항에 따라 달라지며, 일부 애플리케이션은 처리량 향상과 지연 시간 단축을 위해 간헐적인 메시지 손실을 용인할 수 있다.

## 프로듀서에서 컨슈머로 직접 메시지를 보내기

다음은 프로듀서가 컨슈머에게 직접 메시지를 보내는 다이렉트 메시징의 시나리오다.

- UDP 멀티캐스트: UDP 멀티캐스트는 금융 업계에서 지연 시간이 짧은 주식 시장 피드를 위해 사용된다. UDP 자체는 불안정하지만 애플리케이션 수준 프로토콜은 손실된 패킷을 재전송하여 복구할 수 있다.

- 브로커리스 메시징 라이브러리: TCP 또는 IP 멀티캐스트를 통해 게시/구독 메시징을 구현하는 ZeroMQ와 nanomsg가 있다.

- 메트릭을 위한 신뢰할 수 없는 UDP 메시징: StatsD와 Brubeck은 네트워크 메트릭을 수집하기 위해 신뢰할 수 없는 UDP 메시징을 사용한다. 그러나 정확도는 모든 메시지를 수신하는지에 따라 달라진다.

- 직접 HTTP/RPC 요청: 프로듀서는 소비자에게 메시지를 푸시하기 위해 직접 HTTP 또는 RPC 요청을 할 수 있다. 이 개념은 특정 이벤트에 대한 요청을 트리거하기 위해 서비스가 다른 서비스에 콜백 URL을 등록하는 웹훅에서 사용된다.

이러한 다이렉트 메시징 시스템은 설계된 컨텍스트 내에서 효과적이지만 메시지 손실을 처리하기 위해 애플리케이션 코드가 필요한 경우가 많다.
하지만 다이렉트 메시징의 단점은 내결함성이 제한적이며 소비자가 오프라인 상태이거나 프로듀서가 충돌하여 메시지 버퍼를 잃어 재시도할 수 없는 경우 메시지를 놓칠 수 있다는 점이다.

## 메시지 브로커

메시지 브로커는 메시지 스트림 처리에 최적화된 특수한 데이터베이스다.
메시지 브로커는 서버로 작동하며, 프로듀서와 컨슈머는 메시지 브로커에 클라이언트로 연결된다.

### 메시지 브로커에 대한 핵심 사항

- 중앙 집중화: 메시지 브로커는 메시지 데이터를 중앙 집중화하여 연결, 연결 해제 또는 충돌하는 클라이언트를 처리할 수 있도록 한다. 내구성 문제는 브로커에게 전가된다.
- 메시지 저장소: 메시지 브로커는 구성에 따라 메시지를 메모리에 보관하거나 디스크에 기록하여 브로커 충돌 시 메시지 손실을 방지할 수 있다.
- 큐잉: 메시지 브로커는 속도가 느린 컨슈머를 위해 무제한 대기열을 허용하여 메시지 삭제나 역압박을 방지하는 경우가 많다.
- 비동기 처리: 메시지 브로커 시스템의 컨슈머는 일반적으로 비동기식이다. 프로듀서는 메시지를 전송하고 브로커가 메시지를 버퍼링했는지 확인하기만 기다릴뿐이다. 컨슈머에게 실제 메시지가 전달되는 시점은 지정되지 않은 미래의 시간으로, 대개 몇 초 이내이지만 큐 백로그 때문에 그보다 늦어질 수도 있다.
