---
title: "데이터 중심의 애플리케이션 설계 - 원자적 커밋"
toc: true
categories:
  - tech
tags:
  - book
  - design system
  - tech
  - backend
---

트랜잭션의 원자성을 지키는 이유는 쓰기 작업 도중 발생하는 문제로 인한 불일치를 막기 위해서다.

## 단일 노드와 분산 노드에서 원자적 커밋의 차이

단일 데이터베이스 노드의 원자성은 일반적으로 스토리지 엔진에 의해 구현된다. 클라이언트가 데이터베이스 노드에 트랜잭션을 커밋하도록 요청하면 디스크의 로그에 커밋 레코드를 추가한다. 이 프로세스 도중에 데이터베이스가 충돌하면 노드가 다시 시작될 때 로그에서 트랜잭션이 복구된다. 충돌 전에 커밋 레코드가 디스크에 성공적으로 쓰여진 경우 트랜잭션이 커밋된 것으로 간주되며, 그렇지 않은 경우 해당 트랜잭션의 모든 쓰기가 롤백된다.

단일 노드에서 트랜잭션 커밋은 데이터가 디스크에 기록되는 순서에 따라 달라진다. 트랜잭션의 커밋 또는 중단 여부를 결정하는 중요한 순간은 디스크가 커밋 레코드 쓰기를 완료하는 순간이다.
커밋을 원자적으로 만드는 것은 단일 장치인, 노드에 연결된 하나의 디스크 드라이브의 컨트롤러다.

분할된 데이터베이스에 다중 오브젝트 트랜잭션이 있거나 용어 분할 보조 인덱스가 있는 경우는 커밋을 구현하는 방법이 다르다. 대부분의 "NoSQL" 분산 데이터스토어는 이러한 분산 트랜잭션을 지원하지 않지만, 다양한 클러스터 관계형 시스템을 지원한다.

이러한 경우 단순히 모든 노드에 커밋 요청을 보내고 각 노드에서 트랜잭션을 독립적으로 커밋하는 것만으로는 충분하지 않다. 이렇게 하면 일부 노드에서는 커밋이 성공하고 다른 노드에서는 커밋이 실패하여 원자성 보장을 위반하는 일이 쉽게 발생할 수 있다.

- 일부 노드는 제약 조건 위반 또는 충돌을 감지하여 중단이 필요한 반면 다른 노드는 성공적으로 커밋할 수 있다.
- 일부 커밋 요청이 네트워크에서 손실되어 결국 시간 초과로 인해 중단되는 반면 다른 커밋 요청은 통과할 수 있다.
- 일부 노드는 커밋 레코드가 완전히 기록되기 전에 충돌하고 복구 시 롤백되는 반면, 다른 노드는 성공적으로 커밋할 수 있다.

트랜잭션 커밋은 취소할 수 없어야 한다. 트랜잭션이 커밋된 후에는 트랜잭션을 취소할 수 없다. 이유는 데이터가 커밋되면 다른 트랜잭션에 표시되므로 다른 클라이언트가 해당 데이터에 의존할 수 있기 때문이다.
