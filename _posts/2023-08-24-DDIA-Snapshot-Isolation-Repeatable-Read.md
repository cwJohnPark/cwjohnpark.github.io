---
title: "데이터 중심의 애플리케이션 설계 - 스냅샷 격리와 반복 읽기"
toc: true
categories:
  - tech
tags:
  - book
  - design system
  - tech
  - backend
  - transaction
---

ACID의 격리 수준 중 <u>커밋 읽기(Read Committed)</u> 격리 수준을 표면적으로만 보면 트랜잭션이 해야 할 모든 작업을 수행한다.

- 원자성에 필요한 트랜잭션 도중 중단을 허용한다.
- 트랜잭션의 불완전한 결과를 읽지 못하게 한다.
- 동시 쓰기가 섞이는 것을 방지한다.

그러나 커밋 읽기 격리 수준을 사용할 때 동시성 버그가 발생하는 상황은 여전히 많다. 다음의 상황을 가정해보자.

가정: 앨리스가 은행에 1,000달러의 예금을 두 개의 계좌(A,B)에 각각 500달러씩 나누어 예치하고 있다.

1. 앨리스가 트랜잭션을 시작한다. A 은행 계좌에 500달러가 있는 것을 확인 했다.
2. 앨리스의 트랜잭션이 커밋되기 전에 다른 트랜잭션이 앨리스의 A 계좌에서 B 계좌로 100달러를 이체하고 커밋한다.
3. 앨리스의 트랜잭션은 **커밋 읽기** 격리 수준이므로 B계좌를 조회하면 400달러가 잔액임을 확인한다.

<u>앨리스에게는 A계좌와 B게좌에 총 900달러만 있는 것으로 보이며, 100달러는 사라진 것처럼 보인다.</u>

## 읽기 왜곡 Write Skew

이러한 이상 현상을 반복 불가능한 읽기 또는 **읽기 왜곡(write skew)**이라고 한다.
앨리스가 거래가 끝날 때 잔액을 다시 읽으면 이전 쿼리에서 본 것과 다른 값($600)을 보게 된다.
앨리스가 본 계정 잔액은 앨리스가 읽은 시점에 실제로 커밋된 것이다.
앨리스의 경우 몇 초 후에 온라인 뱅킹 웹사이트를 다시 로드하면 계좌 잔액이 일관되게 표시될 것이다.

## 일시적인 불일치가 허용되어선 안되는 경우들

### 백업

백업을 수행하려면 전체 데이터베이스의 복사본을 만들어야 하며, 대규모 데이터베이스의 경우 몇 시간이 걸릴 수 있다.
백업 프로세스가 실행되는 동안 데이터베이스에 대한 쓰기가 계속 이루어진다.
따라서, 백업의 일부에는 이전 버전의 데이터가 포함되고 다른 일부에는 최신 버전이 포함될 수 있다.
이러한 백업에서 복원해야 하는 경우 불일치(예: 사라진 돈)가 영구적으로 발생한다.

### 분석 쿼리 및 무결성 검사

때로는 데이터베이스의 많은 부분을 스캔하는 쿼리를 실행하고 싶을 수 있다.
이러한 쿼리는 분석에서 흔히 사용되거나, 모든 것이 정상인지 확인하는 주기적인 무결성 검사(데이터 손상 모니터링)의 일부가 될 수 있다.
이러한 쿼리는 서로 다른 시점에 데이터베이스의 일부를 관찰하는 경우 무의미한 결과를 반환할 가능성이 높다.

## 읽기 왜곡의 해결책 : 스냅샷 격리

스냅샷 격리는 읽기 왜곡에 대한 가장 일반적인 해결책이다.
이 아이디어는 각 트랜잭션이 시작될 때 데이터베이스에 커밋된 모든 데이터를 읽는다는 것이다.
이후 다른 트랜잭션에 의해 데이터가 변경되더라도 각 트랜잭션은 특정 시점의 이전 데이터만 볼 수 있다.

스냅샷 격리는 백업 및 분석과 같이 장기간 실행되는 읽기 전용 쿼리에 유용하다.
쿼리가 실행되는 동시에 쿼리가 작동하는 데이터가 변경되는 경우 쿼리의 의미를 추론하기가 매우 어렵다.
트랜잭션이 특정 시점에 고정된 데이터베이스의 일관된 스냅샷을 볼 수 있으면 훨씬 더 쉽게 이해할 수 있다.
스냅샷 격리는 널리 사용되는 기능으로, PostgreSQL, InnoDB 스토리지 엔진이 탑재된 MySQL, Oracle, SQL Server 등에서 지원된다.

## 스냅샷 격리 구현

커밋 읽기 격리와 마찬가지로 스냅샷 격리 구현은 일반적으로 쓰기 잠금을 사용하여 더티 쓰기를 방지한다.
쓰기를 하는 트랜잭션이 동일한 오브젝트에 쓰는 다른 트랜잭션의 진행을 차단할 수 있다. 그러나 읽기에는 잠금이 필요하지 않다.

성능 관점에서 볼 때, 스냅샷 격리의 핵심 원칙은 읽기 트랜잭션은 쓰기를 차단하지 않고 쓰기는 읽기 트랜잭션을 차단하지 않는다는 것이다.
이를 통해, 데이터베이스는 쓰기 작업을 정상적으로 처리하는 동시에 일관된 스냅샷에서 장기간 실행되는 읽기 쿼리를 둘 사이의 잠금 경합 없이 처리할 수 있다.

## 스냅샷 격리의 일반화된 메커니즘: 다중 버전 동시성 제어, MVCC

스냅샷 격리를 구현하기 위해 데이터베이스는 더티 읽기를 방지하기 위해 살펴본 메커니즘을 일반화하여 사용한다.
진행 중인 다양한 트랜잭션이 서로 다른 시점의 데이터베이스 상태를 확인해야 할 수 있기 때문에, 데이터베이스는 잠재적으로 여러 개의 서로 다른 커밋된 버전의 객체를 유지해야 한다.
한 개체의 여러 버전을 나란히 유지하기 때문에 이 기술을 **다중 버전 동시성 제어(MVCC)**라고 한다.

데이터베이스가 커밋 읽기 격리만 제공하고 스냅샷 격리는 제공하지 않아도 된다면, 오브젝트의 두 가지 버전(커밋된 버전과 덮어썼지만 아직 커밋되지 않은 버전)을 유지하는 것으로 충분하다. 하지만, 스냅샷 격리를 지원하는 스토리지 엔진은 일반적으로 커밋 읽기 격리 수준에도 MVCC를 사용한다.
일반적인 접근 방식은 커밋 읽기은 각 쿼리에 대해 별도의 스냅샷을 사용하는 반면, 스냅샷 격리는 전체 트랜잭션에 대해 동일한 스냅샷을 사용하는 것이다.

PostgreSQL의 MVCC 기반 스냅샷 격리를 예로 들면,

1. 트랜잭션이 시작한다.
2. 트랜잭션에는 항상 증가하는 고유한 트랜잭션 ID(txid)가 부여된다.
3. 트랜잭션이 데이터베이스에 무언가를 쓸 때마다, 데이터는 작성자의 트랜잭션 ID로 태그가 지정된다.

### MVCC의 트랜잭션 ID는 각 행에 숨어있다.

테이블의 각 행에는 이 행을 테이블에 삽입한 트랜잭션의 ID를 포함하는 `created_by` 필드가 있다. 또한 각 행에는 처음에는 비어 있는 `deleted_by` 필드가 있다.
트랜잭션이 행을 삭제하는 경우 해당 행은 실제로 데이터베이스에서 삭제되지는 않는다.
다만, `deleted_by` 필드가 삭제를 요청한 트랜잭션의 ID로 설정되어 삭제된 것으로 표시된다.

### 트랜잭션 ID는 언제 정리될까?

나중에 어떤 트랜잭션도 더 이상 삭제된 데이터에 액세스할 수 없는 것이 확실해지면, 데이터베이스의 가비지 컬렉션 프로세스가 삭제 표시된 모든 행을 제거하고 해당 공간을 확보한다.

### 일관된 스냅샷을 관찰하기 위한 가시성 규칙

트랜잭션이 데이터베이스에서 읽을 때, 트랜잭션 ID는 어떤 개체를 볼 수 있고 어떤 개체를 볼 수 없는지 결정하는 데 사용된다.
가시성 규칙을 신중하게 정의하면 데이터베이스는 애플리케이션에 일관된 스냅샷을 제공할 수 있다.

가시성 규칙은 다음과 같이 작동한다.

1. 각 트랜잭션이 시작될 때, 데이터베이스는 해당 시점에 진행 중인(아직 커밋되거나 중단되지 않은) 다른 모든 트랜잭션의 목록을 만든다.
   트랜잭션이 나중에 커밋되더라도 해당 트랜잭션이 수행한 모든 쓰기는 무시된다.
2. 중단된 트랜잭션에 의해 수행된 모든 쓰기는 무시된다.
3. 나의 트랜잭션 이후의 트랜잭션 ID를 가진 다른 트랜잭션(즉, 현재 트랜잭션이 시작된 후에 시작된 트랜잭션)이 수행한 모든 쓰기는 해당 트랜잭션이 커밋되었는지 여부와 관계없이 무시된다.
4. 다른 모든 쓰기 요청은 애플리케이션의 쿼리에 표시된다.

다시 말해, 다음 조건이 모두 참이면 개체가 표시된다.

- 리더의 트랜잭션이 시작되었을 때 개체를 생성한 트랜잭션이 이미 커밋되었을 경우
- 개체가 삭제하도록 표시되지 않았거나, 표시되어 있더라도 리더의 트랜잭션이 시작될 때 삭제를 요청한 트랜잭션이 아직 커밋되지 않은 경우

장기 실행 트랜잭션은 스냅샷을 오랫동안 계속 사용하면서 오래 전의 쓰거나 삭제된 값을 계속 읽을 수 있다.
값을 업데이트하지 않고 값이 변경될 때마다 새 버전을 생성하는 대신 데이터베이스는 약간의 오버헤드만 발생시키면서 일관된 스냅샷을 제공할 수 있다.
