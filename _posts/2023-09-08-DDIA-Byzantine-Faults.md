---
title: "데이터 중심의 애플리케이션 설계 - 비잔틴 오류"
toc: true
categories:
  - tech
tags:
  - book
  - design system
  - tech
  - backend
---

펜싱 토큰은 잘못된 행동을 하는 노드를 감지하고 차단할 수 있지만, 악의적인 노드가 가짜 펜싱 토큰을 메시지와 전송하여 시스템을 망가뜨릴 수 있다.
분산 시스템은 노드가 프로토콜에 맞게 행동하지만, GC나 네트워크에 신뢰할 수 없는 경우를 가정해야 한다.

더욱이, 노드가 거짓말을 하여 의도적으로 오류를 내려고 하는 경우는 분산시스템에서 매우 어려운 문제다. 메시지를 받았지만 받지 못했다고 말하는 것이 그 예다.
이러한 문제를 **비잔틴 오류(Byzantine fault)**라고 한다. 그리고, 신뢰 불가능한 환경에서 합의에 도달하기 위한 어려움을 말하는 것이 **비잔틴 장군들의 문제(Byzantine Generals Problem)**이라고 한다.

비잔틴 장군 문제는 다음의 가정을 필요로 한다.

- 두 군대의 장군이 전투 계획에 합의해야 한다.
- 두 장군은 서로 다른 곳에 위치하기 때문에, 메신저를 통해서만 의사소통을 할 수 있다.
- 네트워크의 패킷처럼, 메신저가 지연되거나 끊어지는 경우가 있다.
- 비잔틴 버전의 문제에서는 합의해야 하는 장군이 n명이다.

비잔틴 장군의 문제는 배신하려는 장군의 메시지를 쉽게 신뢰할 수 없음을 말해준다.
장군들 사이에 배신자가 있다는 사실 때문에 장군의 노력이 방해를 받는다.
대부분의 장군들은 충성심이 강하기 때문에 진실한 메시지를 보내지만, 배신자들은 발각되지 않으려고 가짜 혹은 진짜 메시지를 보내 다른 장군들을 속이고 혼란에 빠뜨리려고 할 수 있다.
또한, 배신자가 누구인지는 미리 알 수 없다.

## 비잔틴 장군의 문제의 어원

비잔티움은 고대 그리스의 도시로 나중에 콘스탄티노플이 되었고, 현재 튀르키예의 이스탄불이 되었다.
비잔티움의 장군들이 다른 곳의 장군들보다 음모에 더 취약했다는 역사적 증거는 없다.
오히려 이 이름은 지나치게 복잡하고 관료적이며 교활하다는 의미로 비잔틴에서 유래한 것이다.
사실 이 용어는 컴퓨터가 등장하기 훨씬 전부터 정치에서 사용되어왔다.

## 비잔틴 허용 시스템이 필요한 예

비잔틴 장애 허용 시스템이란 몇몇의 노드가 규약에 따르지 않더라도 올바르게 동작하는 시스템을 말한다.
실제의 컴퓨터 시스템에서의 예제를 들어보면,

- 항공 시스템에서, 컴퓨터 메모리나 CPU 레지스터에 저장된 데이터는 방사능에 의해 망가질 수 있다. 이러한 망가진 데이터가 노드를 예측 불가능하게 행동하도록 한다. 항공 제어 관측 시스템은 비잔틴 오류를 반드시 허용할 수 있어야 한다.
- 하나의 시스템에서 여러 조직들이 참여할 경우, 몇몇의 참가자들이 속임수를 쓰려고 할 수 있다. 이러한 환경에서, 다른 노드가 보낸 단순히 믿을 수 없다. 예를 들어, 비트코인과 같은 피어-투-피어(peer-to-peer) 네트워크, 혹은 블록 체인 기반 시스템이 있다.

비잔틴 오류 허용 시스템의 프로토콜을 만드는 것은 매우 복잡하다. 대부분의 서버 사이드 데이터 시스템이 비잔틴 장애 허용 솔루션을 배포하는 것은 비실용적이다.
웹 애플리케이션은 웹 브라우저로부터 사용자가 잘못된 행동을 할 수 있다는 점을 예상할 수 있어야 한다. 이로 인해, SQL 인젝션, CORS를 방지하기 위한 입력 검증이 필요하다.

프로토콜을 잘 사용하면 시스템을 비잔틴 오류로부터 해결할 수 있을까? 완벽히 프로토콜이 비잔틴 오류를 막는 것은 불가능하다. 대부분의 분산 시스템은 동일한 소프트웨어를 구동하는 경우가 많으므로 공격자가 하나의 노드를 망가뜨리면 다른 노드 역시 망가뜨릴 수 있기 때문이다.

## 입력을 검증하는 일반적인 사례

우리가 운영하는 일반적인 분산 시스템은 노드가 일반적으로 정직하다고 가정하지만, **약한 형태의 거짓말(Weak forms of lying)**에 대해 방어할 필요성은 충분히 있다.
하드웨어 문제로 인한 잘못된 메시지나, 소프트웨어의 버그, 잘못된 설정 등이 그 예다.

- 하드웨어 문제나 OS 내부의 버그, 드라이버, 라우터 등으로 인해 네트워크 패킷은 가끔씩 망가진다. TCP나 UDP에서 체크섬을 사용하여 이러한 잘못된 패킷을 검출할 수 있다.
- 웹 애플리케이션과 같이 공개적으로 접근 가능한 애플리케이션은 사용자의 입력을 살균하는 작업을 면밀히 처리해야 한다. 예를 들어, 입력의 크기나 범위, 문자열의 길이 등을 파악하므로써, 비대한 메모리 할당을 막을 수 있다.
- 네트워크 상에 연결된 장비와 장비 간에 시간 정보를 동기화하기 위한, NTP 클라이언트는 여러 개의 서버 주소들로 설정된다. 시간을 동기화할 때 클라이언트는 모든 서버에 연결하여 오류를 추정하고 대부분의 서버가 특정 시간 범위에 동의하는지 확인한다. 대부분의 서버가 정상이라면 잘못된 시간을 보고하는 잘못 구성된 NTP 서버는 이상값으로 감지되어 동기화에서 제외된다.
